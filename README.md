# BYR Archive

BYR Archive 是 2025 年 [北邮人团队](https://team.byrio.work/) 后端考核题中的一道简单题。图标就不往这儿放了（

考核要求，将代码托管在 `https://git.byr.moe` 或 GitHub，并在 `README.md` 中编写一份简要报告。

本文件就是报告。

## 使用方法

```bash
pip3 install -r requirements.txt  # 这里安装在了全局环境
cd service
python3 tiny_jsdelivr.py
```

## 编写初期的准备工作

这道题目考查了网络编程技术，因此决定选择 Python 语言，搭配上一个网络开发框架。在和 AI 对话（见“AI 使用情况”部分）后决定使用 Flask。

在网上查找资料，看到了一则一个月前的帖子（[链接](https://community.latenode.com/t/get-npm-package-files-directly-without-installing-node-js-or-npm/37598/4)）。帖子讲解了在没有 `node` 和 `npm` 的情况下如何下载 npm 包。例如，通过 URL `https://registry.npmjs.org/is-odd/-/is-odd-3.0.1.tgz` ，就能下载到 `.tgz` 文件，里面包含着源代码。

向出题人询问这个方向是否正确，得到了肯定的答复。出题人同时还指出 `"tarball"` 字段已经有 URL 了，不需要自己去拼 URL。

## AI 使用情况

### 对话

使用了 ChatGPT。（[对话链接](https://chatgpt.com/share/68dca0d8-5ae0-8006-9c7c-9347fde9bcce)）

由于几乎没有网络编程基础，所以一开始问了：

1. 用 Python 如何去搭建出一个服务，从网上拉取信息显示给访问者；
2. 被 `app.route` 装饰的函数（后来知道叫视图函数），它的返回值类型是怎么一回事；
3. 如何让视图函数能匹配任意路径。

最终，参考了它给出的代码框架：

```Python
app = Flask(__name__)

@app.route("/<path:anything>")
def catch_all(anything):
    return f"You asked for /{anything}"

app.run(host="0.0.0.0", port=8080, debug=True)
```

即使只有 5 行，也只有首行和末行几乎没在后期被改过。中间 3 行都被魔改过了。

开发后期还问了：

- 用 [`npm/node-semver`](https://github.com/npm/node-semver) 库时，如何去预编译一个版本范围。

我使用的 Python 库 [`node-semver`](https://pypi.org/project/node-semver/) 的和这个 JS 库 `npm/node-semver` 接口应当基本一致，用法可以类比。正如 Python 中的 `re.compile()` 一样，预编译只是让代码更优雅一些，性能稍高一些。这个改动不做也是可以的。

### 代码自动补全

开发过程中还使用了 VS Code 扩展 [CodeGeeX](https://marketplace.visualstudio.com/items?itemName=aminer.codegeex) 进行代码 AI 补全。用法是打出代码前半句，它可以自动补出后半句，按 Tab 键采纳，期望能够少打一些字。

不过这个代码补全错误率有点高，每次敲 Tab 之前还是得去人工 review 一遍。但至少少敲键盘了。

## 设计思路

服务使用 Flask 框架实现。为实现必选功能，程序大致流程为：

1. 获取访问者输入的包名、版本要求（如果有）、文件/目录路径（如果有）；
2. 从 registry 网站获取携带着元信息的 JSON 文件，找到合适的版本；
3. 下载该版本对应的 tarball 文件，在本地解压，再根据访问者的要求返回文件或目录；
4. 此外，缓存在本地的 tarball 和解压后的文件如果堆积过多，会提醒操作者清理。

除此之外，还做了必选项之外的一些功能：

### 更好的版本号与分发标签支持

我希望访问者能够输入版本号范围，还能通过分发标签寻找版本。

那么为了对版本号有一个初步了解，首先要寻找并阅读相关的规范：

1. 了解“语义化版本号”的一些细节。阅读了 [RFC 2119](https://datatracker.ietf.org/doc/html/rfc2119) 和 [语义化版本 2.0.0](https://semver.org/lang/zh-CN/) 。打消了用 Python 自己造轮子的念头（2333）。找到了一个处理这种东西的 Python 库 [`semver`](https://pypi.org/project/semver/) 。
2. 了解在 `node` 生态中一个版本号范围是如何表示的。阅读了 `npm/node-semver` 中 `README.md` 中的 Ranges 章节（[链接](https://github.com/npm/node-semver/blob/main/README.md#ranges)）。又找到了一个处理这种东西的 Python 库 [`node-semver`](https://pypi.org/project/node-semver/) 。

前者 `semver` 库的各种功能在 `node-semver` 库中应当都已经包含了，所以只需要后者即可。

最终是实现了一套比较花哨的接口。访问者可以：

- 用 `all` 要求查看所有版本，如 `/react@all` 。此时列出包的所有版本号及可能的分发标签。
- 用 `dist-tags` 要求查看所有分发标签，如 `/react@dist-tags` 。此时列出包的所有分发标签和对应的版本号。
- 指定一个版本范围，如 `/react@>=5.0.0 <18.0.0 || 0.14.3` 。此时列出所有满足要求的版本号及可能的分发标签。
- 指定一个确切的版本号，如 `/react@19.2.0` 。此时给出该版本的包的内容。
- 指定一个确切的分发标签，如 `/react@next` 。此时给出该分发标签对应版本的包的内容。
- 只指定包名而不指定版本号，如 `/react` 。此时给出分发标签为 `latest` 的版本的包的内容。

还有简单的错误处理：

- 若没有任何一个版本符合要求（可能是访问者输错了，可能是输入的范围太窄了），也列出包的所有版本号及可能的分发标签。
- 若包名不存在，也会给出相应的提示。

对视觉显示也有一点优化：

- 在展示任意一个版本列表时，总是对于每个版本将分发标签（如果有）写在一旁。
- 在展示任意一个版本列表之前，总是先展示一个小列表，其中只显示那些有着分发标签的版本及对应的分发标签，方便可能需要的访问者。但如果完整列表中的所有版本都已经有了分发标签，则为了不重复，就不展示这个小列表。
- 在展示任意一个版本列表时，在末尾显示列表具体有几个项。
- 在展示任意一个文件列表时，在末尾显示列表具体有几个项。
- 空列表会显示成类似于 `(Empty list)` 的文字。

显示出的版本号都是可以点击的链接，点击后可以跳转到该版本的具体内容，同时保留输入的文件/目录路径（如果有）。例如，访问 `/react@all/cjs/react.production.js` 之后，在版本列表中点击 `19.2.0` 之后，会跳转到 `/react@19.2.0/cjs/react.production.js` ，从而直接显示文件内容。

事实上这和题目上“可选功能”部分的描述有相悖之处。题目中有一个例子是，访问者输入一个版本范围时，会解析到满足该范围的最新版本，而不是将所有满足要求的版本列出来。但列出所有版本或许更灵活一些。

### 文件缓存

使用磁盘对包的内容做了简单的缓存。

需要获取 tarball 或已解压的文件时，若本地没有，则从网络上下载到本地或解压，但从不删除它们。这个过程自然地形成了一个缓存。

但毕竟程序偷懒了不会删除缓存，所以操作者需要手动清理。因此在：

- 程序启动时
- 每当有新文件/目录被缓存时

都会检查缓存文件夹的大小。如果超过了设定好的阈值，就在终端中显示高亮文字，提醒操作者清理，顺便报告占用空间最多的文件/目录，以及它们的大小，方便操作者锁定清理目标。

## 实现时遇到的问题

### 代码组织

题目中希望代码可读性好，符合最佳实践，所以编写过程中一直遵循着一些熟知的、比较细节的原则：

- 代码风格：变量命名风格、如何缩进、遵守 80 字符的要求，等等。它们对于代码组织意义相对较小。
- 将代码组织成基本通用组件，组织成类和函数，少用可变全局变量，多用常量，避免维护复杂状态，诸如此类。这些也都是老生常谈了。

然而在基本遵循这些原则的基础上，由于缺乏经验，在实现时，依然遇到一些有关代码组织的问题，关乎程序的可维护性和可扩展性：

- **异常。** 开始时，代码随意混用断言和各类 `if ... raise` 验证输入合法性，混淆了哪些问题应该由访问者解决，哪些问题应该由程序员解决。后来决定，自定义一个异常类型 `RequestNotValidError` ，表示那些应该由访问者解决的错误（例如，包名为空）。而其他问题则作为所谓的 500 Internal Server Error。将具体处理流程逻辑放在一个函数中，再在视图函数中调用它，同时捕获并分辨异常类型，可读性更好一些。
- **模块化。** 开始时，将所有内容写在了一个脚本中。随着功能逐渐增多，代码也逐渐变长，需要分割成多个模块。所幸代码中各个类和函数之间的耦合度不高，所以很容易就分成了多个模块，还组织出了一个包。
- **调包。** 开始时，我试图自己对文件路径、版本号进行抽象。后来阅读了语义化版本号的规范（见“准备工作”部分），意识到这种轮子不好造，更不该造。于是开始使用 `node-semver` 库（见“更好的版本号与分发标签支持”部分）。对于路径也开始使用标准库模块 `pathlib` 。 `node-semver` 库没有文档，需要参考 JS 库 [`npm/node-semver`](https://github.com/npm/node-semver) 的文档。有一次还向 AI 询问了某个有关的具体问题（见“准备工作”部分），但整体来说还是很顺利的，因为需要调包的地方并不密集，而且都通过一层抽象，隔离在了业务部分（主程序）之外。

### 其他小插曲

- **弯路。** 访问 `https://cdn.jsdelivr.net/npm/react@latest/index.js` ，一敲 F12，一看“元素”界面，清晰可见的 `<html>` `</head>` 之类的标签就映入眼帘了。于是便用了与显示目录类似的技术，写了一个 HTML 模板来专门显示文本文件内容。甚至为了能让文本文件能够正确显示，还进行了 HTML 转义。完全忘记了对于文本文件应该直接返回其内容！直到用 `curl` 测试了一下，重新访问上个 URL，才醒悟过来，文件内容是不需要也不应该塞进 HTML 里的。我所看到的那些标签是浏览器自动添加的。想象一个程序只是想获取某个包的 `package.json` 文件并解析它，爬下来之后想得到的 JSON 内容却夹在一大堆 HTML 标签中间，甚至还转义过，这显然是不合适的。
- **图标。** 输入网址进行测试时，总是在终端看到代码在用 `requests` 试图访问 `https://registry.npmjs.org/favicon.ico` 从而报错。阅读日志并思考之后，明白是 Chrome 浏览器在向我的程序请求这个东西。于是自己画了个图标放了进来，并在代码中对 `/favicon.ico` 路径做了特判。于是既消灭了报错，还让自己的网站有了一个图标。
- **JSON 文件解析。** 开始时，注意到对于 `react` 包从 registry 网站获取的 [JSON 文件](`https://registry.npmjs.org/react`) 体积有 5.8 MB，在浏览器中显示时已经有些吃力。试着用标准库模块 `json` 进行解析，发现速度其实很快。担心纯属多余，没有必要使用流式 JSON 库。
- **其他小 bug。** 例如元信息 JSON 中的 `"dist-tags"` 字典（对象）是从分发标签映射到版本的，在构造逆映射时忘记考虑多个标签可能对应同一个版本，导致怪异的显示 bug。这类 bug 都很容易定位以及修复。

## 优缺点分析

总结上方内容就能得出一些优缺点了。

优点：

- 代码在细节上基本符合良好实践；
- 有着一定程度的模块化，控制了代码量；
- 错误处理方面，明确了服务器内部错误和应该由访问者改正的错误；
- 缓存了文件和目录，减少了 npm registry 的访问次数，并能给出文件尺寸信息提醒操作者清理；
- 对版本号范围和分发标签做了更全面、更灵活的支持，并对列表有着少量的视觉优化。

缺点：

- 代码在整体上称不上整洁；
- 由于缺乏相关经验，模块化进行得较为生硬；
- 错误处理仍不完善，因为网络编程知识欠缺，无法考虑周到；
- 缓存机制自动化程度低，依赖操作者手动清理。
- 并没有实现“可选功能”部分中的“压缩/打包功能”。

## 心路历程

大部分心路历程在前文中其实已经体现了，但这里还可以补充一点。

知道了 tarball URL 的获取方式，导致刚开始不久就明确了程序大体流程。但还是被现实的复杂性打脸了。

比如，从访问者提供的路径中，能够解析出包名和对版本的要求。我试着在解析过程中直接得到所有符合要求的版本，然而在实现时才发觉获取全部版本需要元信息 JSON 文件，而它是在后续步骤中才下载的。于是不得不重新进行设计，延后了“筛选符合要求的版本”这一过程。这是可能是没有明确数据流向导致的。

编写代码以及撰写文档的过程中，逐渐可以认识到自己：

- 过去编写的那些代码，处理的东西仿佛都是“真空中的球形数据”；
- 思维是“小型程序”的思维，没有真正在稍大一点的规模上思考；
- 虽然知道一些软件工程的方法论，但没有在实践中应用过。

这些潜藏的问题因为一道网络编程简单题就暴露出来了。

不能只有理论知识。理论和实践相结合，才能达到更高的技术水平。
